<?php
/**
 * @file
 * Main module file for Webform Multiple (WFM).
 */

/**
 * TODO
 * 1. Fix display for Date and Grid components.
 * 2. Remove unnecessary array expansion / nested value reading, perhaps.
 * 3. Support file components properly.
 * 4. Add support for tokens.
 * 5. Add support for conditionals.
 * 6. Correct for components that have been removed from their parents since
 *    submission.
 */

define('WFM_UNLIMITED', -1);

/**
 * Implements hook_form_FORM_ID_alter().
 */
function wfm_form_webform_component_edit_form_alter(&$form, &$form_state) {
  $component = $form_state['build_info']['args'][1];
  if (!in_array($component['type'], _wfm_supported_components())) {
    return;
  }
  $form['wfm'] = array(
    '#type' => 'fieldset',
    '#title' => t('Multiple values'),
    '#weight' => 10,
  );
  $form['wfm']['max_items'] = array(
    '#type' => 'select',
    '#title' => t('Maximum number of values'),
    '#description' => t("The maximum number of values users can enter for this component. 'Unlimited' will allow users to add as many values as they like."),
    '#options' => drupal_map_assoc(range(1, 10)) + array(WFM_UNLIMITED => t('Unlimited')),
    '#default_value' => _wfm_get_max_items($component),
  );
  $form['wfm']['min_items'] = array(
    '#type' => 'select',
    '#title' => t('Initial (fixed) number of values'),
    '#options' => drupal_map_assoc(range(1, 10)),
    '#default_value' => _wfm_get_min_items($component),
    '#states' => array(
      'invisible' => array(
        ':input[name="wfm[max_items]"]' => array('value' => 1),
      ),
    ),
  );
  $form['wfm']['add_more_text'] = array(
    '#type' => 'textfield',
    '#title' => t('"Add another" button text'),
    '#default_value' => _wfm_get_add_text($component),
    '#states' => array(
      'invisible' => array(
        ':input[name="wfm[max_items]"]' => array('value' => 1),
      ),
    ),
  );
}

/**
 * Implements hook_webform_component_presave().
 *
 * Save the component's multiple-values settings.
 */
function wfm_webform_component_presave(&$component) {
  if (!isset($component['wfm']['max_items'])) {
    return;
  }
  $max_items = $component['wfm']['max_items'];
  $component['extra']['wfm_max_items'] = $max_items;
  $min_items = $component['wfm']['min_items'];
  // The minimum number of items cannot be greater than the maximum.
  if ($max_items != WFM_UNLIMITED && $min_items > $max_items) {
    $min_items = $max_items;
  }
  $component['extra']['wfm_min_items'] = $min_items;
  $component['extra']['wfm_add_more_text'] = $component['wfm']['add_more_text'];
}

/**
 * Implements hook_webform_submission_render_alter().
 */
function wfm_webform_submission_render_alter(&$renderable) {
  $node = $renderable['#node'];
  $submission = $renderable['#submission'];
  $format = $renderable['#format'];
  if ($format == 'html' || $format == 'text') {
    $form_state = array();
    foreach (element_children($renderable) as $form_key) {
      $element = &$renderable[$form_key];
      _wfm_process_elements($element, $form_state, $submission, TRUE, $format);
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function wfm_form_webform_client_form_alter(&$form, &$form_state) {
  $node = $form['#node'];
  $submission = $form['#submission'];
  foreach ($node->webform['components'] as $cid => $component) {
    $form_key = $component['form_key'];
    // Move component children under the parent element.
    if ($component['pid'] > 0) {
      $parent_component = $node->webform['components'][$component['pid']];
      $parent_component_key = $parent_component['form_key'];
      if (_wfm_is_multiple($parent_component) && isset($form['submitted'][$parent_component_key][$form_key])) {
        $form['submitted'][$parent_component_key][0][$form_key] = $form['submitted'][$parent_component_key][$form_key];
        unset($form['submitted'][$parent_component_key][$form_key]);
      }
    }
    if (isset($form['submitted'][$form_key])) {
      _wfm_process_elements($form['submitted'][$form_key], $form_state, $submission);
    }
  }
  array_unshift($form['#submit'], 'wfm_submit');
}


/**
 * Process an element in the Webform to allow multiple values.
 *
 * @param array &$element
 *   The Form API element.
 * @param array &$form_state
 *   The Form API form state.
 * @param stdClass $submission
 *   The Webform submission object.
 */
function _wfm_process_elements(&$element, &$form_state, $submission, $display = FALSE, $format = 'html') {
  $component = $element['#webform_component'];
  $form_key = $component['form_key'];
  $cid = $component['cid'];
  $element_name = isset($element['#name']) ? $element['#name'] : "submitted[$form_key]";
  $element_parents = isset($element['#parents']) ? $element['#parents'] : array('submitted', $form_key);
  $element_wfm_parents = isset($element['#wfm_parents']) ? $element['#wfm_parents'] : array($cid);
  $form_state['wfm_ancestors'][$cid][implode('.', $element_parents)] = $element_parents;

  // Get the current item count for this component.
  $new = FALSE;
  if (!isset($form_state['wfm_deltas'][$element_name])) {
    $new = TRUE;
    for ($i = 0; $i < _wfm_get_min_items($component); $i++) {
      $form_state['wfm_deltas'][$element_name][$i] = $i;
    }
  }

  // Stop processing if this component does not accept multiple values.
  if (!_wfm_is_multiple($component)) {
    if ($submission && $new) {
      $value = drupal_array_get_nested_value($submission->wfm_data, $element_wfm_parents, $exists);
      if ($exists) {
        $value = isset($value[0]) ? $value[0] : $value;
        $element['#default_value'] = $value;
        if ($display) {
          $element['#value'] = $value;
        }
        if ($component['type'] == 'date') {
          $element['#value'] = NULL;
        }
      }
    }
    return;
  }

  $max_items = _wfm_get_max_items($component);
  $initial_weight = isset($element['#weight']) ? $element['#weight'] : 1;

  // Replace the element with a parent container.
  if (!isset($element['#wfm_wrapper'])) {
    $wrapper_id = drupal_html_id('wfm-container-' . $form_key);
    $element = array(
      '#type' => 'container',
      '#wfm_wrapper' => TRUE,
      '#webform_component' => $component,
      '#attributes' => array('id' => $wrapper_id, 'class' => array('wfm-container')),
      '#wrapper_id' => $wrapper_id,
      '#weight' => $initial_weight,
      '#name' => $element_name,
      '#parents' => $element_parents,
      '#wfm_parents' => $element_wfm_parents,
    );
    // Add the 'Add another item' button.
    if (!$display) {
      $element['add_more'] = array(
        '#type' => 'submit',
        '#value' => _wfm_get_add_text($component),
        '#weight' => $initial_weight + 0.5,
        '#name' => 'add_more',
        '#limit_validation_errors' => array(array('submitted', $form_key)),
        '#submit' => array('wfm_add_more_submit'),
        '#attributes' => array('class' => array('wfm-add')),
        '#ajax' => array(
          'callback' => 'wfm_js',
          'wrapper' => $wrapper_id,
        ),
      );
    }
  }

  if ($submission && $new) {
    $element_value = drupal_array_get_nested_value($submission->wfm_data, $element['#wfm_parents'], $exists);
    if ($exists) {
      $element_deltas = array_keys($element_value);
      foreach ($element_deltas as $delta) {
        if (!isset($form_state['wfm_deltas'][$element_name][$delta])) {
          $form_state['wfm_deltas'][$element_name][$delta] = $delta;
        }
      }
    }
  }

  $min_items = $component['extra']['wfm_min_items'];

  $item_count = count($form_state['wfm_deltas'][$element_name]);

  $item_number = 1;
  foreach ($form_state['wfm_deltas'][$element_name] as $delta) {

    // Remove the 'Add another item' button where appropriate.
    $final = ($item_count == $max_items);
    if ($final) {
      unset($element['add_more']);
    }
    elseif (!$display) {
      // Somehow, for AJAX to process properly, the button name needs to be
      // specified as unique to this item. This might be a cache issue.
      $element['add_more']['#name'] .= $element_name . '_add_more_' . $delta;
    }

    // Define the parents of the item.
    $wfm_parents = $element['#wfm_parents'];
    $wfm_parents[] = $delta;

    // Get the default value of the item.
    $default_value = NULL;
    if ($submission && $new && empty($component['children'])) {
      $default_value = drupal_array_get_nested_value($submission->wfm_data, $wfm_parents);
    }

    // Generate any new form items needed. They are all added as children of the
    // parent $element, keyed by $delta.
    if (!isset($element[$delta])) {
      $new_element = _wfm_component_element_render($component, $display, $default_value, $format);
      $new_element['#weight'] = $initial_weight + ($delta / 100);
      // Add wfm CSS classes to the element.
      if ($delta == $item_count - 1) {
        $new_element['#attributes']['class'][] = 'wfm-last';
        if ($final) {
          $new_element['#attributes']['class'][] = 'wfm-final';
        }
      }
      $element[$delta] = $new_element;
    }

    // Process new and existing form items.
    $item = &$element[$delta];
    $item['#name'] = $element_name . "[$delta]";
    $item['#parents'] = $wfm_parents;
    $item['#wfm_parents'] = $wfm_parents;

    // Add the item's children (e.g. if it's a fieldset).
    if (!empty($component['children'])) {
      foreach ($component['children'] as $scid => $sub_component) {
        $sub_component_key = $sub_component['form_key'];
        $sub_item_wfm_parents = $item['#wfm_parents'];
        $sub_item_wfm_parents[] = $scid;
        array_unshift($sub_item_wfm_parents, $scid);
        if (!isset($item[$sub_component_key])) {
          $sub_item_value = NULL;
          if ($display && $submission && $new) {
            $sub_item_value = drupal_array_get_nested_value($submission->wfm_data, $sub_item_wfm_parents, $scid);
          }
          $item[$sub_component_key] = _wfm_component_element_render($sub_component, $display, $sub_item_value, $format);
        }
        $sub_item = &$item[$sub_component_key];
        $sub_item['#name'] = $item['#name'] . "[$sub_component_key]";
        $sub_item['#parents'] = $item['#parents'];
        $sub_item['#parents'][] = $sub_component_key;
        $sub_item['#wfm_parents'] = $sub_item_wfm_parents;
        $form_state['wfm_ancestors'][$scid][implode('.', $sub_item['#parents'])] = $sub_item['#parents'];
        // Recursively process any multiple-value children.
        _wfm_process_elements($sub_item, $form_state, $submission, $display);
      }
    }
    elseif ($default_value) {
      $item['#default_value'] = $default_value;
      if ($display) {
        $item['#value'] = $default_value;
      }
    }

    // Append numbering to the form input's title.
    if ($item_count > 1) {
      $item['#title'] = t('@title (@num/@count)', array(
        '@title' => $item['#title'],
        '@num' => $item_number,
        '@count' => $item_count,
      ));
    }

    // Add a 'Remove' button, to appear just after the form input.
    if ($item_count > $min_items && !$display) {
      $element['remove_' . $delta] = array(
        '#type' => 'submit',
        '#value' => t('Remove'),
        '#limit_validation_errors' => array(),
        '#submit' => array('wfm_remove_submit'),
        '#attributes' => array('class' => array('wfm-remove')),
        '#ajax' => array(
          'callback' => 'wfm_js',
          'wrapper' => $element['#wrapper_id'],
        ),
        '#weight' => $item['#weight'] + 0.001,
        // As with the 'add more' button, for AJAX to process properly, the
        // button name needs to be specified as unique to this item.
        '#name' => $element_name . '_remove_' . $delta,
      );
    }

    $item_number++;

  }
}

/**
 * Submit callback for the 'Add another item' button.
 */
function wfm_add_more_submit(&$form, &$form_state) {
  $button = $form_state['triggering_element'];
  $element = &drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -1));
  $component = $element['#webform_component'];
  $element_name = $element['#name'];
  $item_count = count($form_state['wfm_deltas'][$element_name]);
  $next_delta = end($form_state['wfm_deltas'][$element_name]) + 1;
  $max_items = _wfm_get_max_items($component);
  if ($max_items == WFM_UNLIMITED || $item_count < $max_items) {
    $form_state['wfm_deltas'][$element_name][$next_delta] = $next_delta;
  }
  $form_state['rebuild'] = TRUE;
}

/**
 * Submit callback for the 'Remove item' button.
 */
function wfm_remove_submit(&$form, &$form_state) {
  $button = $form_state['triggering_element'];
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -1));
  $component = $element['#webform_component'];
  $cid = $component['cid'];
  $element_name = $element['#name'];
  $delta = substr($button['#name'], strlen($element_name . '_remove_'));
  unset($form_state['wfm_deltas'][$element_name][$delta]);
  $form_state['rebuild'] = TRUE;
}

/**
 * AJAX callback for the 'Add another item' or 'Remove' buttons.
 */
function wfm_js($form, $form_state) {
  // No need to do anything here, just return the (possibly changed) element.
  $button = $form_state['triggering_element'];
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -1));
  return $element;
}

/**
 * Submit callback for the webform, running before Webform callbacks.
 */
function wfm_submit($form, &$form_state) {
  // Multistep forms might not have any components on the first page.
  if (!isset($form_state['values']['submitted'])) {
    $form_state['values']['submitted'] = array();
  }

  // Remove all non-component values, except 'details' and 'op' which are needed
  // by webform_client_form_pages().
  $details = $form_state['values']['details'];
  $op = $form_state['values']['op'];
  form_state_values_clean($form_state);
  $form_state['values']['details'] = $details;
  $form_state['values']['op'] = $op;

  // Build a list of component IDs keyed by their 'form_key' string properties.
  $node = $form['#node'];
  $components = $node->webform['components'];
  $cids_by_key = array();
  foreach ($components as $cid => $component) {
    $cids_by_key[$component['form_key']] = $cid;
  }

  /*
   * Flatten the $form_state['values']['submitted'] array in such a way that it
   * can be further processed by Webform.
   *
   * Webform expects to get an array like:
   *   array($parent_key => array($component_key => $value))
   * for every component.
   *
   * The value in $value can be either scalar or a single-dimensional array.
   */
  $component_ancestors = $form_state['wfm_ancestors'];
  $values = array();
  // Go through all the non-group components, getting their values and
  // identifying where they should have extra identification added describing
  // the hierarchy of their parents.
  foreach ($components as $cid => $component) {
    // Only act on components that were processed by Webform Multiple.
    if (!isset($component_ancestors[$cid])) {
      continue;
    }

    // Only act on non-group components.
    if (webform_component_feature($component['type'], 'group')) {
      continue;
    }

    // Check whether the component, or any of its ancestors, is multiple-value.
    $is_multiple_recursive = _wfm_is_multiple_recursive($component, $components);

    // Loop through all the possible family trees for this component.
    foreach ($component_ancestors[$cid] as $ancestors) {
      // Remove 'submitted' from the ancestors array.
      array_shift($ancestors);

      // Get the component's value.
      $value = drupal_array_get_nested_value($form_state['values']['submitted'], $ancestors, $set);
      if (!$set) {
        continue;
      }

      // Recursively check if the value is empty (equivalent to 0), and if so
      // stop processing.
      $value = _wfm_filter_recursive($value);
      if (!$value) {
        continue;
      }

      // Make sure the value is an array;
      $value = (array) $value;

      // If this component is multiple-value, or if it's a descendant of any
      // multiple-value components, then prefix each of its array keys with a
      // string describing the component's ancestors. The array keys are used in
      // the database column {webform_submitted_data}.`no`.
      $ancestors_count = count($ancestors);
      if ($ancestors_count > 1 && $is_multiple_recursive) {
        $delta_prefix = '';
        // Each array element will be prefixed by something like '1|2#0|3#0|4',
        // where the delta keys are the numbers preceded by hash signs, and the
        // other integers are component IDs.
        foreach ($ancestors as $key => $ancestor) {
          if ($key < $ancestors_count) {
            if ($key > 0) {
              $delta_prefix .= is_int($ancestor) ? '#' : '|';
            }
            // If the ancestor is a form key, convert it to a component ID.
            if (!is_int($ancestor)) {
              $ancestor = $cids_by_key[$ancestor];
            }
            $delta_prefix .= $ancestor;
          }
        }
        $value_prefixed = array();
        foreach ($value as $delta => $sub_value) {
          $new_delta = $delta_prefix . '#' . $delta;
          $value_prefixed[$new_delta] = $sub_value;
        }
        $value = $value_prefixed;
      }

      // Add each value to the $values array, with a similar structure but now
      // with only string array keys, representing components' 'form keys'
      // (removing the deltas).
      $ancestors = array_filter($ancestors, 'is_string');
      foreach ($value as $key => $data) {
        $value_parents = $ancestors;
        $value_parents[] = $key;
        drupal_array_set_nested_value($values, $value_parents, $data, TRUE);
      }
    }
  }
  $form_state['values']['submitted'] = $values;

}

/**
 * Implements hook_webform_submission_load().
 */
function wfm_webform_submission_load(&$submissions) {
  foreach ($submissions as $sid => $submission) {
    if (!isset($submission->wfm_data)) {
      $original_data = $submission->data;
      $submission->wfm_data = array();
      foreach ($original_data as $cid => $data) {
        $submission->wfm_data[$cid] = _wfm_submission_data_expand($data);
        $submission->data[$cid] = array(0 => _wfm_submission_data_to_string($data));
      }
      _wfm_submission_data_expand_parents($submission->wfm_data, $original_data);
    }
  }
}

/**
 * Convert submission data into a descriptive string.
 *
 * @todo make more human-readable
 */
function _wfm_submission_data_to_string(array $data) {
  if (count($data) == 1 && isset($data[0])) {
    return $data[0];
  }
  $output = '';
  foreach ($data as $key => $value) {
    if (preg_match_all('/#([0-9]+)/', $key, $deltas)) {
      $deltas = $deltas[1];
      foreach ($deltas as &$delta) {
        $delta++;
      }
      $output .= implode('>', $deltas) . ': ';
    }
    else {
      $output .= $key + 1 . ': ';
    }
    $output .= $value . "\n\n";
  }
  return $output;
}

/**
 * Expand submission data into a multi-dimensional array.
 */
function _wfm_submission_data_expand(array $data) {
  $output = array();
  foreach ($data as $key => $value) {
    if (strpos($key, '|') === FALSE) {
      $output[$key] = $value;
      continue;
    }
    $key_parts = preg_split('/[#\|]/', $key);
    drupal_array_set_nested_value($output, $key_parts, $value, TRUE);
  }
  return $output;
}

/**
 * Add information to wfm_data containing the delta count of parent components.
 */
function _wfm_submission_data_expand_parents(&$wfm_data, $data) {
  foreach ($data as $cid => $value) {
    foreach ($value as $key => $sub_value) {
      if (strpos($key, '|') !== FALSE && strpos($key, '#') !== FALSE) {
        $key_components = explode('|', $key);
        foreach ($key_components as $part) {
          list($pid, $delta) = explode('#', $part);
          if (!isset($data[$pid]) && !isset($wfm_data[$pid][$delta])) {
            $wfm_data[$pid][$delta] = $delta;
          }
        }
      }
    }
  }
}

/**
 * Filter an array recursively.
 *
 * If all of the array's values are '' or NULL return NULL.
 */
function _wfm_filter_recursive($array) {
  if (!is_array($array)) {
    return $array;
  }
  $filled = FALSE;
  foreach ($array as &$value) {
    if (is_array($value)) {
      $value = _wfm_filter_recursive($value);
    }
    if (is_array($value) || ($value !== '' && $value !== NULL)) {
      $filled = TRUE;
    }
  }
  return $filled ? $array : NULL;
}

/**
 * Helper function to render a repeatable Webform component as a form element.
 */
function _wfm_component_element_render($component, $display = FALSE, $value = NULL, $format = 'html') {
  if ($display) {
    $element = webform_component_invoke($component['type'], 'display', $component, $value, $format);
  }
  else {
    $element = webform_component_invoke($component['type'], 'render', $component, $value);
  }
  $element['#webform_component'] = $component;
  if (!isset($element['#attributes']['class'])) {
    $element['#attributes']['class'] = array();
  }
  $element['#attributes']['class'][] = 'wfm';
  drupal_alter(($display ? 'webform_component_display' : 'webform_component_render'), $element, $component);
  return $element;
}

/**
 * Check whether a component takes multiple values.
 */
function _wfm_is_multiple($component) {
  $max_items = _wfm_get_max_items($component);
  return $max_items > 1 || $max_items == WFM_UNLIMITED;
}

/**
 * Check whether a component, or any of its ancestors, takes multiple values.
 */
function _wfm_is_multiple_recursive($component, $components) {
  if ($component['pid'] != 0 && isset($components[$component['pid']])) {
    $parent_component = $components[$component['pid']];
    if (_wfm_is_multiple_recursive($parent_component, $components)) {
      return TRUE;
    }
  }
  return _wfm_is_multiple($component);
}

/**
 * Get the max_items of a component.
 *
 * This is the equivalent of 'cardinality' in the Field system.
 */
function _wfm_get_max_items(array $component) {
  $max_items = 1;
  if (isset($component['extra']['wfm_max_items'])) {
    $max_items = (int) $component['extra']['wfm_max_items'];
  }
  return $max_items;
}

/**
 * Get the sanitized 'add more' text of a component.
 *
 * Default: 'Add another item'.
 */
function _wfm_get_add_text(array $component) {
  $add_more_text = t('Add another item');
  if (isset($component['extra']['wfm_add_more_text'])) {
    $add_more_text = check_plain($component['extra']['wfm_add_more_text']);
  }
  return $add_more_text;
}

/**
 * Get the minimum number of items of a component.
 */
function _wfm_get_min_items(array $component) {
  $min_items = 1;
  if (isset($component['extra']['wfm_min_items'])) {
    $min_items = (int) $component['extra']['wfm_min_items'];
  }
  return $min_items;
}

/**
 * Get a list of the components supported by this module.
 */
function _wfm_supported_components() {
  return array(
    'email',
    'fieldset',
    'file',
    'name',
    'number',
    'textarea',
    'textfield',
    'time',
  );
}
