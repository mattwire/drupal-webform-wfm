<?php
/**
 * @file
 * Main module file for Webform Multiple (WFM).
 */

define('WFM_UNLIMITED', -1);

/**
 * Implements hook_form_FORM_ID_alter().
 */
function wfm_form_webform_component_edit_form_alter(&$form, &$form_state) {
  $component = $form_state['build_info']['args'][1];
  if (!in_array($component['type'], _wfm_supported_components())) {
    return;
  }
  $form['wfm'] = array(
    '#type' => 'fieldset',
    '#title' => t('Multiple values'),
    '#weight' => 10,
  );
  $form['wfm']['max_items'] = array(
    '#type' => 'select',
    '#title' => t('Maximum number of values'),
    '#description' => t("The maximum number of values users can enter for this component. 'Unlimited' will allow users to add as many values as they like."),
    '#options' => drupal_map_assoc(range(1, 10)) + array(WFM_UNLIMITED => t('Unlimited')),
    '#default_value' => _wfm_get_max_items($component),
  );
  $form['wfm']['min_items'] = array(
    '#type' => 'select',
    '#title' => t('Initial (fixed) number of values'),
    '#options' => drupal_map_assoc(range(1, 10)),
    '#default_value' => _wfm_get_min_items($component),
    '#states' => array(
      'invisible' => array(
        ':input[name="wfm[max_items]"]' => array('value' => 1),
      ),
    ),
  );
  $form['wfm']['add_more_text'] = array(
    '#type' => 'textfield',
    '#title' => t('"Add another" button text'),
    '#default_value' => _wfm_get_add_text($component),
    '#states' => array(
      'invisible' => array(
        ':input[name="wfm[max_items]"]' => array('value' => 1),
      ),
    ),
  );
}

/**
 * Implements hook_webform_component_presave().
 *
 * Save the component's multiple-values settings.
 */
function wfm_webform_component_presave(&$component) {
  if (!isset($component['wfm']['max_items'])) {
    return;
  }
  $max_items = $component['wfm']['max_items'];
  $component['extra']['wfm_max_items'] = $max_items;
  $min_items = $component['wfm']['min_items'];
  // The minimum number of items cannot be greater than the maximum.
  if ($max_items != WFM_UNLIMITED && $min_items > $max_items) {
    $min_items = $max_items;
  }
  $component['extra']['wfm_min_items'] = $min_items;
  $component['extra']['wfm_add_more_text'] = $component['wfm']['add_more_text'];
}

/**
 * Implements hook_webform_component_display_alter().
 */
function wfm_webform_component_display_alter(&$element, &$component) {
  // @todo display multiple values
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function wfm_form_webform_client_form_alter(&$form, &$form_state) {
  $node = $form['#node'];
  foreach ($node->webform['components'] as $cid => $component) {
    $form_key = $component['form_key'];
    // Move component children under the parent element.
    if ($component['pid'] > 0) {
      $parent_component = $node->webform['components'][$component['pid']];
      $parent_component_key = $parent_component['form_key'];
      if (_wfm_is_multiple($parent_component) && isset($form['submitted'][$parent_component_key][$form_key])) {
        $form['submitted'][$parent_component_key][0][$form_key] = $form['submitted'][$parent_component_key][$form_key];
        unset($form['submitted'][$parent_component_key][$form_key]);
      }
    }
    if (isset($form['submitted'][$form_key])) {
      _wfm_process_elements($form['submitted'][$form_key], $form_state);
    }
  }
  array_unshift($form['#submit'], 'wfm_submit');
}


/**
 * Process an element to add items to it.
 */
function _wfm_process_elements(&$element, &$form_state) {
  $component = $element['#webform_component'];
  $form_key = $component['form_key'];
  $cid = $component['cid'];
  $element_name = isset($element['#name']) ? $element['#name'] : "submitted[$form_key]";
  $element_parents = isset($element['#parents']) ? $element['#parents'] : array('submitted', $form_key);
  $form_state['wfm_ancestors'][$cid][implode('.', $element_parents)] = $element_parents;
  if (!_wfm_is_multiple($component)) {
    return;
  }
  $max_items = _wfm_get_max_items($component);
  $initial_weight = isset($element['#weight']) ? $element['#weight'] : 1;
  if (!isset($element['#wfm_wrapper'])) {
    $wrapper_id = drupal_html_id('wfm-container-' . $form_key);
    // Move the element into a parent container.
    $element = array(
      '#type' => 'container',
      0 => $element,
      '#wfm_wrapper' => TRUE,
      '#webform_component' => $component,
      '#attributes' => array('id' => $wrapper_id, 'class' => array('wfm-container')),
      '#wrapper_id' => $wrapper_id,
      '#weight' => $initial_weight,
      '#parents' => $element_parents,
    );
    // Add the 'Add another item' button.
    $element['add_more'] = array(
      '#type' => 'submit',
      '#value' => _wfm_get_add_text($component),
      '#weight' => $initial_weight + 0.5,
      '#name' => $form_key . '_add_more',
      '#limit_validation_errors' => array(array('submitted', $form_key)),
      '#submit' => array('wfm_add_more_submit'),
      '#attributes' => array('class' => array('wfm-add')),
      '#ajax' => array(
        'callback' => 'wfm_js',
        'wrapper' => $wrapper_id,
      ),
    );
  }
  $element['#name'] = $element_name;
  $item_count = _wfm_get_min_items($component);
  if (isset($form_state['wfm_item_counts'][$element_name])) {
    $item_count = $form_state['wfm_item_counts'][$element_name];
  }
  $min_items = $component['extra']['wfm_min_items'];
  $removed_deltas = array();
  $num_removed = 0;
  if (isset($form_state['wfm_remove'][$element_name])) {
    $removed_deltas = $form_state['wfm_remove'][$element_name];
    $num_removed = count($removed_deltas);
  }
  $item_number = 1;
  for ($delta = 0; $delta < $item_count; $delta++) {

    // 'Removed' items keep their own $delta values.
    if (in_array($delta, $removed_deltas)) {
      unset($element[$delta]);
      continue;
    }

    // Remove the 'Add another item' button where appropriate.
    $final = ($item_count - $num_removed == $max_items);
    if ($final) {
      unset($element['add_more']);
    }

    // Generate any new form items needed. They are all added as children of the
    // parent $element, keyed by $delta.
    if (!isset($element[$delta])) {
      $new_element = _wfm_component_element_render($component);
      $new_element['#weight'] = $initial_weight + ($delta / 100);
      // Add wfm CSS classes to the element.
      if ($delta == $item_count - 1) {
        $new_element['#attributes']['class'][] = 'wfm-last';
        if ($final) {
          $new_element['#attributes']['class'][] = 'wfm-final';
        }
      }
      $element[$delta] = $new_element;
    }

    // Process new and existing form items.
    $item = &$element[$delta];
    $item['#name'] = $element['#name'] . "[$delta]";
    $item['#parents'] = $element['#parents'];
    $item['#parents'][] = $delta;

    // Add the item's children (e.g. if it's a fieldset).
    if (!empty($component['children'])) {
      foreach ($component['children'] as $scid => $sub_component) {
        $sub_component_key = $sub_component['form_key'];
        if (!isset($item[$sub_component_key])) {
          $item[$sub_component_key] = _wfm_component_element_render($sub_component);
        }
        $sub_item = &$item[$sub_component_key];
        $sub_item['#name'] = $item['#name'] . "[$sub_component_key]";
        $sub_item['#parents'] = $item['#parents'];
        $sub_item['#parents'][] = $sub_component_key;
        $form_state['wfm_ancestors'][$scid][implode('.', $sub_item['#parents'])] = $sub_item['#parents'];
        // Recursively process any multiple-value children.
        _wfm_process_elements($sub_item, $form_state);
      }
    }

    // Append numbering to the form input's title.
    if ($item_count - $num_removed > 1) {
      $item['#title'] = t('@title (@num/@count)', array(
        '@title' => $item['#title'],
        '@num' => $item_number++,
        '@count' => $item_count - $num_removed,
      ));
    }

    // Add a 'Remove' button, to appear just after the form input.
    if ($item_count - $num_removed > $min_items) {
      $element['remove_' . $delta] = array(
        '#type' => 'submit',
        '#value' => t('Remove'),
        '#limit_validation_errors' => array(),
        '#submit' => array('wfm_remove_submit'),
        '#attributes' => array('class' => array('wfm-remove')),
        '#ajax' => array(
          'callback' => 'wfm_js',
          'wrapper' => $element['#wrapper_id'],
        ),
        '#weight' => $item['#weight'] + 0.001,
        '#name' => $element['#name'] . '_remove_' . $delta,
      );
    }
  }
}

/**
 * Submit callback for the 'Add another item' button.
 */
function wfm_add_more_submit(&$form, &$form_state) {
  $button = $form_state['triggering_element'];
  $element = &drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -1));
  $component = $element['#webform_component'];
  $cid = $component['cid'];
  $element_name = $element['#name'];
  $num_removed = 0;
  if (isset($form_state['wfm_remove'][$element_name])) {
    $num_removed = count($form_state['wfm_remove'][$element_name]);
  }
  if (!isset($form_state['wfm_item_counts'][$element_name])) {
    $form_state['wfm_item_counts'][$element_name] = 1;
  }
  $item_count = &$form_state['wfm_item_counts'][$element_name];
  $max_items = _wfm_get_max_items($component);
  if ($max_items == WFM_UNLIMITED || $item_count - $num_removed < $max_items) {
    $item_count++;
  }
  $form_state['rebuild'] = TRUE;
}

/**
 * Submit callback for the 'Remove item' button.
 */
function wfm_remove_submit(&$form, &$form_state) {
  $button = $form_state['triggering_element'];
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -1));
  $component = $element['#webform_component'];
  $cid = $component['cid'];
  $element_name = $element['#name'];
  $delta = substr($button['#name'], strlen($element['#name'] . '_remove_'));
  $form_state['wfm_remove'][$element_name][] = $delta;
  $form_state['rebuild'] = TRUE;
}

/**
 * AJAX callback for the 'Add another item' or 'Remove' buttons.
 */
function wfm_js($form, $form_state) {
  // No need to do anything here, just return the (possibly changed) element.
  $button = $form_state['triggering_element'];
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -1));
  return $element;
}

/**
 * Submit callback for the webform, running before Webform callbacks.
 */
function wfm_submit($form, &$form_state) {
  // Multistep forms might not have any components on the first page.
  if (!isset($form_state['values']['submitted'])) {
    $form_state['values']['submitted'] = array();
  }

  // Remove all non-component values, except 'details' and 'op' which are needed
  // by webform_client_form_pages().
  $details = $form_state['values']['details'];
  $op = $form_state['values']['op'];
  form_state_values_clean($form_state);
  $form_state['values']['details'] = $details;
  $form_state['values']['op'] = $op;

  /*
   * Flatten the $form_state['values']['submitted'] array in such a way that it
   * can be further processed by Webform.
   *
   * Webform expects to get an array like:
   *   array($parent_key => array($component_key => $value))
   * for every component.
   *
   * The value in $value can be either scalar or a single-dimensional array.
   */
  $node = $form['#node'];
  $components = $node->webform['components'];
  $component_ancestors = $form_state['wfm_ancestors'];
  $values = array();
  // Go through all the non-group components, getting their values and
  // identifying where they should have extra identification added describing
  // the hierarchy of their parents.
  foreach ($components as $cid => $component) {
    // Only act on components that were processed by Webform Multiple.
    if (!isset($component_ancestors[$cid])) {
      continue;
    }

    // Only act on non-group components.
    if (webform_component_feature($component['type'], 'group')) {
      continue;
    }

    // Check whether the component, or any of its ancestors, is multiple-value.
    $is_multiple_recursive = _wfm_is_multiple_recursive($component, $components);

    // Loop through all the possible family trees for this component.
    foreach ($component_ancestors[$cid] as $ancestors) {
      // Remove 'submitted' from the ancestors array.
      array_shift($ancestors);

      // Get the component's value.
      $value = drupal_array_get_nested_value($form_state['values']['submitted'], $ancestors, $set);
      if (!$set) {
        continue;
      }

      // Recursively check if the value is empty (equivalent to 0), and if so
      // stop processing.
      $value = _wfm_filter_recursive($value);
      if (!$value) {
        continue;
      }

      // Make sure the value is an array;
      $value = (array) $value;

      // If this component is multiple-value, or if it's a descendant of any
      // multiple-value components, then prefix each of its array keys with a
      // string describing the component's ancestors. The array keys are used in
      // the database column {webform_submitted_data}.`no`.
      $ancestors_count = count($ancestors);
      if ($ancestors_count > 1 && $is_multiple_recursive) {
        $delta_prefix = '';
        // Each array key will be something like
        // 'greatgrandparent|grandparent:1|parent|0', where the integers
        // represent $delta keys.
        foreach ($ancestors as $key => $ancestor) {
          if ($key < $ancestors_count - 1) {
            if ($key > 0) {
              $delta_prefix .= is_int($ancestor) ? ':' : '|';
            }
            $delta_prefix .= $ancestor;
          }
        }
        $value_prefixed = array();
        foreach ($value as $delta => $sub_value) {
          $new_delta = $delta_prefix . '|' . $delta;
          $value_prefixed[$new_delta] = $sub_value;
        }
        $value = $value_prefixed;
      }

      // Add each value to the $values array, with a similar structure but
      // now with only string array keys (i.e. remove the $delta keys).
      $ancestors = array_filter($ancestors, 'is_string');
      foreach ($value as $key => $data) {
        $value_parents = $ancestors;
        $value_parents[] = $key;
        drupal_array_set_nested_value($values, $value_parents, $data, TRUE);
      }
    }
  }
  $form_state['values']['submitted'] = $values;

}

/**
 * Filter an array recursively.
 *
 * If all of the array's values are '' or NULL return NULL.
 */
function _wfm_filter_recursive($array) {
  if (!is_array($array)) {
    return $array;
  }
  $filled = FALSE;
  foreach ($array as &$value) {
    if (is_array($value)) {
      $value = _wfm_filter_recursive($value);
    }
    if (is_array($value) || ($value !== '' && $value !== NULL)) {
      $filled = TRUE;
    }
  }
  return $filled ? $array : NULL;
}

/**
 * Helper function to render a repeatable Webform component as a form element.
 */
function _wfm_component_element_render($component) {
  $elements = &drupal_static(__FUNCTION__, array());
  if (!isset($elements[$component['cid']])) {
    $element = webform_component_invoke($component['type'], 'render', $component);
    $element['#webform_component'] = $component;
    if (!isset($element['#attributes']['class'])) {
      $element['#attributes']['class'] = array();
    }
    $element['#attributes']['class'][] = 'wfm';
    drupal_alter('webform_component_render', $element, $component);
    $elements[$component['cid']] = $element;
  }
  return $elements[$component['cid']];
}

/**
 * Check whether a component takes multiple values.
 */
function _wfm_is_multiple($component) {
  $max_items = _wfm_get_max_items($component);
  return $max_items > 1 || $max_items == WFM_UNLIMITED;
}

/**
 * Check whether a component, or any of its ancestors, takes multiple values.
 */
function _wfm_is_multiple_recursive($component, $components) {
  if ($component['pid'] != 0 && isset($components[$component['pid']])) {
    $parent_component = $components[$component['pid']];
    if (_wfm_is_multiple_recursive($parent_component, $components)) {
      return TRUE;
    }
  }
  return _wfm_is_multiple($component);
}

/**
 * Get the max_items of a component.
 *
 * This is the equivalent of 'cardinality' in the Field system.
 */
function _wfm_get_max_items(array $component) {
  $max_items = 1;
  if (isset($component['extra']['wfm_max_items'])) {
    $max_items = (int) $component['extra']['wfm_max_items'];
  }
  return $max_items;
}

/**
 * Get the sanitized 'add more' text of a component.
 *
 * Default: 'Add another item'.
 */
function _wfm_get_add_text(array $component) {
  $add_more_text = t('Add another item');
  if (isset($component['extra']['wfm_add_more_text'])) {
    $add_more_text = check_plain($component['extra']['wfm_add_more_text']);
  }
  return $add_more_text;
}

/**
 * Get the minimum number of items of a component.
 */
function _wfm_get_min_items(array $component) {
  $min_items = 1;
  if (isset($component['extra']['wfm_min_items'])) {
    $min_items = (int) $component['extra']['wfm_min_items'];
  }
  return $min_items;
}

/**
 * Get a list of the components supported by this module.
 */
function _wfm_supported_components() {
  return array(
    'email',
    'fieldset',
    'file',
    'grid',
    'name',
    'number',
    'textarea',
    'textfield',
    'time',
  );
}
